From 9475b49c5e68699f2c48b0b8839ca901d747da74 Mon Sep 17 00:00:00 2001
From: Cedric Neveux <cedric.neveux@nxp.com>
Date: Tue, 10 Mar 2020 10:23:18 +0100
Subject: [PATCH 55/87] TEE-491 drivers: caam: implement NXP CAAM - DSA

Add the NXP driver:
  - DSA

Signed-off-by: Cedric Neveux <cedric.neveux@nxp.com>
---
 core/arch/arm/plat-imx/crypto_conf.mk         |   5 +-
 core/drivers/crypto/caam/acipher/caam_dsa.c   | 909 ++++++++++++++++++
 .../crypto/caam/acipher/caam_prime_dsa.c      | 753 +++++++++++++++
 core/drivers/crypto/caam/acipher/local.h      |  17 +
 core/drivers/crypto/caam/acipher/sub.mk       |   1 +
 core/drivers/crypto/caam/caam_ctrl.c          |   7 +
 .../crypto/caam/include/caam_acipher.h        |  16 +
 .../caam/include/caam_desc_ccb_defines.h      |  10 +-
 .../crypto/caam/include/caam_desc_defines.h   |  27 +-
 .../crypto/caam/include/caam_desc_helper.h    |  40 +-
 core/drivers/crypto/caam/include/caam_trace.h |  24 +
 11 files changed, 1803 insertions(+), 6 deletions(-)
 create mode 100644 core/drivers/crypto/caam/acipher/caam_dsa.c
 create mode 100644 core/drivers/crypto/caam/acipher/caam_prime_dsa.c

diff --git a/core/arch/arm/plat-imx/crypto_conf.mk b/core/arch/arm/plat-imx/crypto_conf.mk
index 369722bf..833b9c03 100644
--- a/core/arch/arm/plat-imx/crypto_conf.mk
+++ b/core/arch/arm/plat-imx/crypto_conf.mk
@@ -23,6 +23,7 @@
 # DBG_MP     BIT32(12) // MP trace
 # DBG_SM     BIT32(13) // Secure Memory trace
 # DBG_DH     BIT32(14) // DH Trace
+# DBG_DSA    BIT32(15) // DSA trace
 CFG_DBG_CAAM_TRACE ?= 0x2
 CFG_DBG_CAAM_DESC ?= 0x0
 CFG_DBG_CAAM_BUF ?= 0x0
@@ -103,9 +104,11 @@ ifneq ($(filter y, $(CFG_MX6QP) $(CFG_MX6Q) $(CFG_MX6D) $(CFG_MX6DL) \
 $(eval $(call cryphw-enable-drv-hw, ECC))
 $(eval $(call cryphw-enable-drv-hw, RSA))
 $(eval $(call cryphw-enable-drv-hw, DH))
+$(eval $(call cryphw-enable-drv-hw, DSA))
 endif
 
-$(call force, CFG_NXP_CAAM_ACIPHER_DRV, $(call cryphw-one-enabled, ECC RSA DH))
+$(call force, CFG_NXP_CAAM_ACIPHER_DRV, $(call cryphw-one-enabled, \
+	ECC RSA DH DSA))
 
 ifeq ($(CFG_IMX_DEK_HAB),y)
 CFG_PTA_DEK ?= y
diff --git a/core/drivers/crypto/caam/acipher/caam_dsa.c b/core/drivers/crypto/caam/acipher/caam_dsa.c
new file mode 100644
index 00000000..9363f74e
--- /dev/null
+++ b/core/drivers/crypto/caam/acipher/caam_dsa.c
@@ -0,0 +1,909 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright 2019-2020 NXP
+ *
+ * Implementation of DSA functions
+ */
+#include <caam_acipher.h>
+#include <caam_common.h>
+#include <caam_hal_ctrl.h>
+#include <caam_jr.h>
+#include <caam_utils_mem.h>
+#include <caam_utils_sgt.h>
+#include <caam_utils_status.h>
+#include <drvcrypt.h>
+#include <drvcrypt_acipher.h>
+#include <mm/core_memprot.h>
+#include <tee/cache.h>
+#include <string.h>
+
+#include "local.h"
+
+/*
+ * Definition of the local DSA Keypair
+ *   Domain Parameters (p, q, g)
+ *   Private Key format (x)
+ *   Public Key format (y)
+ */
+struct caam_dsa_keypair {
+	struct caambuf g; /* Generator */
+	struct caambuf p; /* Prime Number (L bits) */
+	struct caambuf q; /* Subprime Number (N bits) */
+	struct caambuf x; /* Private key */
+	struct caambuf y; /* Public key */
+};
+
+/*
+ * Free local DSA keypair
+ *
+ * @key  DSA keypair
+ */
+static void do_keypair_free(struct caam_dsa_keypair *key)
+{
+	caam_free_buf(&key->g);
+	caam_free_buf(&key->p);
+	caam_free_buf(&key->q);
+	caam_free_buf(&key->x);
+	caam_free_buf(&key->y);
+}
+
+/*
+ * If all DSA parameters p, q and g are present, convert them from bignumbers
+ * to local buffers (via keypair object).
+ * Otherwise generate them.
+ *
+ * @outkey    [out] Output keypair in local format
+ * @inkey     Input key in TEE Crypto format
+ * @l_bytes   Prime p size in bytes
+ * @n_bytes   Subprime q size in bytes
+ */
+static TEE_Result get_keypair_domain_params(struct caam_dsa_keypair *outkey,
+					    const struct dsa_keypair *key,
+					    size_t l_bytes, size_t n_bytes)
+{
+	enum caam_status retstatus = CAAM_OUT_MEMORY;
+	size_t in_q_size = 0;
+	size_t in_p_size = 0;
+	size_t in_g_size = 0;
+	struct prime_dsa prime = {};
+
+	DSA_TRACE("DSA conv key param (p, g) of %zu bytes and (q) of %zu bytes",
+		  l_bytes, n_bytes);
+
+	retstatus = caam_calloc_buf(&outkey->q, n_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return TEE_ERROR_OUT_OF_MEMORY;
+
+	retstatus = caam_calloc_buf(&outkey->g, l_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return TEE_ERROR_OUT_OF_MEMORY;
+
+	retstatus = caam_calloc_buf(&outkey->p, l_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return TEE_ERROR_OUT_OF_MEMORY;
+
+	/*
+	 * Get all inputs parameters size, if one of them is not
+	 * define generate new parameters
+	 */
+	in_g_size = crypto_bignum_num_bytes(key->g);
+	in_p_size = crypto_bignum_num_bytes(key->p);
+	in_q_size = crypto_bignum_num_bytes(key->q);
+
+	if (!in_q_size || !in_g_size || !in_p_size) {
+		/* Generate DSA parameters: Generator G and Primes P/Q */
+		prime.g = &outkey->g;
+		prime.p = &outkey->p;
+		prime.q = &outkey->q;
+
+		retstatus = caam_prime_dsa_gen(&prime);
+		DSA_TRACE("Generate G and Primes P/Q returned 0x%" PRIx32,
+			  retstatus);
+
+		if (retstatus != CAAM_NO_ERROR)
+			return TEE_ERROR_GENERIC;
+
+		/* Copy Generated DSA Parameter */
+		crypto_bignum_bin2bn(outkey->q.data, outkey->q.length, key->q);
+		crypto_bignum_bin2bn(outkey->g.data, outkey->g.length, key->g);
+		crypto_bignum_bin2bn(outkey->p.data, outkey->p.length, key->p);
+
+	} else {
+		DSA_TRACE("Prime Q is defined");
+
+		crypto_bignum_bn2bin(key->q,
+				     outkey->q.data + n_bytes - in_q_size);
+		cache_operation(TEE_CACHECLEAN, outkey->q.data,
+				outkey->q.length);
+
+		DSA_TRACE("Prime G is defined");
+		crypto_bignum_bn2bin(key->g,
+				     outkey->g.data + l_bytes - in_g_size);
+		cache_operation(TEE_CACHECLEAN, outkey->g.data,
+				outkey->g.length);
+
+		DSA_TRACE("Prime P is defined");
+		crypto_bignum_bn2bin(key->p,
+				     outkey->p.data + l_bytes - in_p_size);
+		cache_operation(TEE_CACHECLEAN, outkey->p.data,
+				outkey->p.length);
+	}
+
+	return TEE_SUCCESS;
+}
+
+/*
+ * Convert Crypto DSA Private Key to local Keypair Key
+ * Ensure Key is push in physical memory
+ *
+ * @outkey    [out] Output keypair in local format
+ * @inkey     Input key in TEE Crypto format
+ * @l_bytes   Prime p size in bytes
+ * @n_bytes   Subprime q size in bytes
+ */
+static enum caam_status do_keypriv_conv(struct caam_dsa_keypair *outkey,
+					const struct dsa_keypair *inkey,
+					size_t l_bytes, size_t n_bytes)
+{
+	enum caam_status retstatus = CAAM_OUT_MEMORY;
+	size_t field_size = 0;
+
+	DSA_TRACE("DSA Convert Key Private size l=%zu bytes, n=%zu bytes",
+		  l_bytes, n_bytes);
+
+	/* Generator */
+	retstatus = caam_calloc_buf(&outkey->g, l_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return CAAM_OUT_MEMORY;
+
+	/* Get the number of bytes of g to pad with 0's */
+	field_size = crypto_bignum_num_bytes(inkey->g);
+	crypto_bignum_bn2bin(inkey->g, outkey->g.data + l_bytes - field_size);
+
+	/* Prime Number Modulus */
+	retstatus = caam_calloc_buf(&outkey->p, l_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return CAAM_OUT_MEMORY;
+
+	/* Get the number of bytes of p to pad with 0's */
+	field_size = crypto_bignum_num_bytes(inkey->p);
+	crypto_bignum_bn2bin(inkey->p, outkey->p.data + l_bytes - field_size);
+
+	/* Subprime Number Modulus */
+	retstatus = caam_calloc_buf(&outkey->q, n_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return CAAM_OUT_MEMORY;
+
+	/* Get the number of bytes of q to pad with 0's */
+	field_size = crypto_bignum_num_bytes(inkey->q);
+	crypto_bignum_bn2bin(inkey->q, outkey->q.data + n_bytes - field_size);
+
+	/* Private key is only scalar x of n bytes */
+	retstatus = caam_calloc_buf(&outkey->x, n_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return CAAM_OUT_MEMORY;
+
+	/* Get the number of bytes of x to pad with 0's */
+	field_size = crypto_bignum_num_bytes(inkey->x);
+	crypto_bignum_bn2bin(inkey->x, outkey->x.data + n_bytes - field_size);
+
+	cache_operation(TEE_CACHECLEAN, outkey->g.data, outkey->g.length);
+	cache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);
+	cache_operation(TEE_CACHECLEAN, outkey->q.data, outkey->q.length);
+	cache_operation(TEE_CACHECLEAN, outkey->x.data, outkey->x.length);
+
+	return CAAM_NO_ERROR;
+}
+
+/*
+ * Convert Crypto DSA Public Key to local DSA Keypair Key
+ * Ensure Key is push in physical memory
+ *
+ * @outkey    [out] Output keypair in local format
+ * @inkey     Input key in TEE Crypto format
+ * @l_bytes   Prime p size in bytes
+ * @n_bytes   Subprime q size in bytes
+ */
+static enum caam_status do_keypub_conv(struct caam_dsa_keypair *outkey,
+				       const struct dsa_public_key *inkey,
+				       size_t l_bytes, size_t n_bytes)
+{
+	enum caam_status retstatus = CAAM_OUT_MEMORY;
+	size_t field_size = 0;
+
+	DSA_TRACE("DSA Convert Public Key size l=%zu bytes, n=%zu bytes",
+		  l_bytes, n_bytes);
+
+	/* Generator */
+	retstatus = caam_calloc_buf(&outkey->g, l_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return CAAM_OUT_MEMORY;
+
+	/* Get the number of bytes of g to pad with 0's */
+	field_size = crypto_bignum_num_bytes(inkey->g);
+	crypto_bignum_bn2bin(inkey->g, outkey->g.data + l_bytes - field_size);
+
+	/* Prime Number Modulus */
+	retstatus = caam_calloc_buf(&outkey->p, l_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return CAAM_OUT_MEMORY;
+
+	/* Get the number of bytes of p to pad with 0's */
+	field_size = crypto_bignum_num_bytes(inkey->p);
+	crypto_bignum_bn2bin(inkey->p, outkey->p.data + l_bytes - field_size);
+
+	/* Subprime Number Modulus */
+	retstatus = caam_calloc_buf(&outkey->q, n_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return CAAM_OUT_MEMORY;
+
+	/* Get the number of bytes of q to pad with 0's */
+	field_size = crypto_bignum_num_bytes(inkey->q);
+	crypto_bignum_bn2bin(inkey->q, outkey->q.data + n_bytes - field_size);
+
+	/* Public key is only scalar y of l bytes */
+	retstatus = caam_calloc_buf(&outkey->y, l_bytes);
+	if (retstatus != CAAM_NO_ERROR)
+		return CAAM_OUT_MEMORY;
+
+	/* Get the number of bytes of y to pad with 0's */
+	field_size = crypto_bignum_num_bytes(inkey->y);
+	crypto_bignum_bn2bin(inkey->y, outkey->y.data + l_bytes - field_size);
+
+	cache_operation(TEE_CACHECLEAN, outkey->g.data, outkey->g.length);
+	cache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);
+	cache_operation(TEE_CACHECLEAN, outkey->q.data, outkey->q.length);
+	cache_operation(TEE_CACHECLEAN, outkey->y.data, outkey->y.length);
+
+	return CAAM_NO_ERROR;
+}
+
+/*
+ * Allocate a TEE DSA keypair.
+ *
+ * @key        Keypair
+ * @l_bits     L bits size (prime p size)
+ * @n_bits     N bits size (subprime q size)
+ */
+static TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,
+				      size_t n_bits)
+{
+	DSA_TRACE("DSA allocate Keypair of L=%zu bits and N=%zu bits", l_bits,
+		  n_bits);
+
+	/* Initialize the key fields to NULL */
+	memset(key, 0, sizeof(*key));
+
+	/* Allocate Generator Scalar */
+	key->g = crypto_bignum_allocate(l_bits);
+	if (!key->g)
+		goto err_alloc_keypair;
+
+	/* Allocate Prime Number Modulus */
+	key->p = crypto_bignum_allocate(l_bits);
+	if (!key->p)
+		goto err_alloc_keypair;
+
+	/* Allocate Prime Number Modulus */
+	key->q = crypto_bignum_allocate(n_bits);
+	if (!key->q)
+		goto err_alloc_keypair;
+
+	/* Allocate Private key X */
+	key->x = crypto_bignum_allocate(n_bits);
+	if (!key->x)
+		goto err_alloc_keypair;
+
+	/* Allocate Public Key Y */
+	key->y = crypto_bignum_allocate(l_bits);
+	if (!key->y)
+		goto err_alloc_keypair;
+
+	return TEE_SUCCESS;
+
+err_alloc_keypair:
+	DSA_TRACE("Allocation error");
+
+	crypto_bignum_free(key->g);
+	crypto_bignum_free(key->p);
+	crypto_bignum_free(key->q);
+	crypto_bignum_free(key->x);
+
+	return TEE_ERROR_OUT_OF_MEMORY;
+}
+
+/*
+ * Allocate a DSA Public Key
+ *
+ * @key        Public Key
+ * @l_bits     L bits size (prime p size)
+ * @n_bits     N bits size (subprime q size)
+ */
+static TEE_Result do_allocate_publickey(struct dsa_public_key *key,
+					size_t l_bits, size_t n_bits)
+{
+	DSA_TRACE("DSA Allocate Public of L=%zu bits and N=%zu bits", l_bits,
+		  n_bits);
+
+	/* Initialize the key fields to NULL */
+	memset(key, 0, sizeof(*key));
+
+	/* Allocate Generator Scalar */
+	key->g = crypto_bignum_allocate(l_bits);
+	if (!key->g)
+		goto err_alloc_pubkey;
+
+	/* Allocate Prime Number Modulus */
+	key->p = crypto_bignum_allocate(l_bits);
+	if (!key->p)
+		goto err_alloc_pubkey;
+
+	/* Allocate Prime Number Modulus */
+	key->q = crypto_bignum_allocate(n_bits);
+	if (!key->q)
+		goto err_alloc_pubkey;
+
+	/* Allocate Public Key Y */
+	key->y = crypto_bignum_allocate(l_bits);
+	if (!key->y)
+		goto err_alloc_pubkey;
+
+	return TEE_SUCCESS;
+
+err_alloc_pubkey:
+	DSA_TRACE("Allocation error");
+
+	crypto_bignum_free(key->g);
+	crypto_bignum_free(key->p);
+	crypto_bignum_free(key->q);
+
+	return TEE_ERROR_OUT_OF_MEMORY;
+}
+
+/*
+ * Generates an DSA keypair
+ * Keypair @key contains the input primes p, g and generator g values
+ * The function calculates private x and public y.
+ *
+ * @key        [in/out] Keypair
+ * @l_bits     L bits size (prime p size)
+ * @n_bits     N bits size (subprime q size)
+ */
+static TEE_Result do_gen_keypair(struct dsa_keypair *key, size_t l_bits,
+				 size_t n_bits)
+{
+	TEE_Result ret = TEE_ERROR_GENERIC;
+	enum caam_status retstatus = CAAM_FAILURE;
+	struct caam_dsa_keypair caam_dsa_key = {};
+	struct caam_jobctx jobctx = {};
+	uint32_t *desc = NULL;
+	uint32_t desclen = 0;
+	size_t l_bytes = l_bits / 8;
+	size_t n_bytes = n_bits / 8;
+
+#ifdef CFG_CAAM_64BIT
+#define MAX_DESC_KEY_GEN 14
+#else
+#define MAX_DESC_KEY_GEN 9
+#endif
+	DSA_TRACE("Generate Key - Private (%zu bits) and Public (%zu bits)",
+		  n_bits, l_bits);
+
+	/* Allocate the job used to prepare the operation */
+	desc = caam_calloc_desc(MAX_DESC_KEY_GEN);
+	if (!desc) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_gen_keypair;
+	}
+
+	/* Allocate Private Key to be generated */
+	retstatus = caam_calloc_align_buf(&caam_dsa_key.x, n_bytes);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_gen_keypair;
+	}
+	cache_operation(TEE_CACHEFLUSH, caam_dsa_key.x.data,
+			caam_dsa_key.x.length);
+
+	/* Allocate Public Key to be generated */
+	retstatus = caam_calloc_align_buf(&caam_dsa_key.y, l_bytes);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_gen_keypair;
+	}
+	cache_operation(TEE_CACHEFLUSH, caam_dsa_key.y.data,
+			caam_dsa_key.y.length);
+
+	/* Generator and Prime */
+	ret = get_keypair_domain_params(&caam_dsa_key, key, l_bytes, n_bytes);
+	if (ret != TEE_SUCCESS)
+		goto exit_gen_keypair;
+
+	/*
+	 * Build the descriptor using the PDB Public Key generation
+	 * block (PD=0)
+	 */
+	caam_desc_init(desc);
+	caam_desc_add_word(desc, DESC_HEADER(0));
+	caam_desc_add_word(desc, PDB_DL_KEY_L_SIZE(l_bytes) |
+					 PDB_DL_KEY_N_SIZE(n_bytes));
+	caam_desc_add_ptr(desc, caam_dsa_key.p.paddr);
+	caam_desc_add_ptr(desc, caam_dsa_key.q.paddr);
+	caam_desc_add_ptr(desc, caam_dsa_key.g.paddr);
+	caam_desc_add_ptr(desc, caam_dsa_key.x.paddr);
+	caam_desc_add_ptr(desc, caam_dsa_key.y.paddr);
+	caam_desc_add_word(desc, PK_KEYPAIR_GEN(DL));
+
+	desclen = caam_desc_get_len(desc);
+	caam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));
+
+	DSA_DUMPDESC(desc);
+
+	jobctx.desc = desc;
+	retstatus = caam_jr_enqueue(&jobctx, NULL);
+
+	if (retstatus == CAAM_NO_ERROR) {
+		cache_operation(TEE_CACHEINVALIDATE, caam_dsa_key.x.data,
+				caam_dsa_key.x.length);
+		cache_operation(TEE_CACHEINVALIDATE, caam_dsa_key.y.data,
+				caam_dsa_key.y.length);
+
+		/* Copy Private and Public keypair */
+		ret = crypto_bignum_bin2bn(caam_dsa_key.x.data,
+					   caam_dsa_key.x.length, key->x);
+		if (ret != TEE_SUCCESS)
+			goto exit_gen_keypair;
+
+		ret = crypto_bignum_bin2bn(caam_dsa_key.y.data,
+					   caam_dsa_key.y.length, key->y);
+		if (ret != TEE_SUCCESS)
+			goto exit_gen_keypair;
+
+		DSA_DUMPBUF("X", caam_dsa_key.x.data, caam_dsa_key.x.length);
+		DSA_DUMPBUF("Y", caam_dsa_key.y.data, caam_dsa_key.y.length);
+
+		ret = TEE_SUCCESS;
+	} else {
+		DSA_TRACE("CAAM Status 0x%08" PRIx32, jobctx.status);
+		ret = job_status_to_tee_result(jobctx.status);
+	}
+
+exit_gen_keypair:
+	caam_free_desc(&desc);
+	do_keypair_free(&caam_dsa_key);
+
+	return ret;
+}
+
+/*
+ * Signature of DSA message
+ * Note the message to sign is already hashed
+ *
+ * @sdata    [in/out] DSA data to sign / Signature
+ * @l_bytes  L bytes size (prime p size)
+ * @n_bytes  N bytes size (subprime q size)
+ */
+static TEE_Result do_sign(struct drvcrypt_sign_data *sdata, size_t l_bytes,
+			  size_t n_bytes)
+{
+	TEE_Result ret = TEE_ERROR_GENERIC;
+	enum caam_status retstatus = CAAM_FAILURE;
+	struct dsa_keypair *inkey = sdata->key;
+	struct caam_dsa_keypair dsakey = {};
+	struct caam_jobctx jobctx = {};
+	uint32_t *desc = NULL;
+	uint32_t desclen = 0;
+	struct caambuf msg_tmp = {};
+	struct caamsgtbuf msg_sgt = { .sgt_type = false };
+	paddr_t paddr_msg = 0;
+	int realloc = 0;
+	size_t sign_len = 0;
+	struct caambuf sign_c_tmp = {};
+	struct caambuf sign_d_tmp = {};
+	struct caamsgtbuf sign_c_sgt = { .sgt_type = false };
+	struct caamsgtbuf sign_d_sgt = { .sgt_type = false };
+	paddr_t paddr_sign_c = 0;
+	paddr_t paddr_sign_d = 0;
+	uint32_t pdb_sgt_flags = 0;
+
+#ifdef CFG_CAAM_64BIT
+#define MAX_DESC_SIGN 19
+#else
+#define MAX_DESC_SIGN 12
+#endif
+
+	DSA_TRACE("DSA Signature");
+
+	/* Allocate the job descriptor */
+	desc = caam_calloc_desc(MAX_DESC_SIGN);
+	if (!desc) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_sign;
+	}
+
+	/* Convert the private key to a local key */
+	retstatus = do_keypriv_conv(&dsakey, inkey, l_bytes, n_bytes);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_sign;
+	}
+
+	/* Prepare the input message CAAM Descriptor entry */
+	msg_tmp.data = sdata->message.data;
+	msg_tmp.length = sdata->message.length;
+	msg_tmp.paddr = virt_to_phys(sdata->message.data);
+	if (!caam_mem_is_cached_buf(sdata->message.data, sdata->message.length))
+		msg_tmp.nocache = 1;
+
+	retstatus = caam_sgt_build_block_data(&msg_sgt, NULL, &msg_tmp);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_GENERIC;
+		goto exit_sign;
+	}
+
+	if (msg_sgt.sgt_type) {
+		pdb_sgt_flags |= PDB_SGT_PKSIGN_MSG;
+		paddr_msg = virt_to_phys(msg_sgt.sgt);
+		caam_sgt_cache_op(TEE_CACHECLEAN, &msg_sgt);
+	} else {
+		paddr_msg = msg_sgt.buf->paddr;
+		if (!msg_sgt.buf->nocache)
+			cache_operation(TEE_CACHECLEAN, msg_sgt.buf->data,
+					msg_sgt.length);
+	}
+
+	DSA_DUMPBUF("Message", sdata->message.data, sdata->message.length);
+
+	/*
+	 * ReAllocate the signature result buffer with a maximum size
+	 * of the roundup to 16 bytes of the secure size in bytes if
+	 * the signature buffer is not aligned or too short.
+	 *
+	 *  - 1st Part: size_sec
+	 *  - 2nd Part: size_sec roundup to 16 bytes
+	 */
+	sign_len = ROUNDUP(sdata->size_sec, 16) + sdata->size_sec;
+
+	realloc = caam_set_or_alloc_align_buf(sdata->signature.data,
+					      &sign_c_tmp, sign_len);
+	if (realloc == -1) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_sign;
+	}
+
+	/* Prepare the 1st Part of the signature */
+	sign_c_tmp.length = sdata->size_sec;
+	retstatus = caam_sgt_build_block_data(&sign_c_sgt, NULL, &sign_c_tmp);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_GENERIC;
+		goto exit_sign;
+	}
+
+	if (sign_c_sgt.sgt_type) {
+		pdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_C;
+		paddr_sign_c = virt_to_phys(sign_c_sgt.sgt);
+		caam_sgt_cache_op(TEE_CACHEFLUSH, &sign_c_sgt);
+	} else {
+		paddr_sign_c = sign_c_sgt.buf->paddr;
+		if (!sign_c_sgt.buf->nocache)
+			cache_operation(TEE_CACHEFLUSH, sign_c_sgt.buf->data,
+					sign_c_sgt.length);
+	}
+
+	/* Prepare the 2nd Part of the signature */
+	sign_d_tmp.data = sign_c_tmp.data + sdata->size_sec;
+	sign_d_tmp.length = ROUNDUP(sdata->size_sec, 16);
+	sign_d_tmp.paddr = virt_to_phys(sign_d_tmp.data);
+	sign_d_tmp.nocache = sign_c_tmp.nocache;
+
+	retstatus = caam_sgt_build_block_data(&sign_d_sgt, NULL, &sign_d_tmp);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_GENERIC;
+		goto exit_sign;
+	}
+
+	if (sign_d_sgt.sgt_type) {
+		pdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_D;
+		paddr_sign_d = virt_to_phys(sign_d_sgt.sgt);
+		caam_sgt_cache_op(TEE_CACHEFLUSH, &sign_d_sgt);
+	} else {
+		paddr_sign_d = sign_d_sgt.buf->paddr;
+		if (!sign_d_sgt.buf->nocache)
+			cache_operation(TEE_CACHEFLUSH, sign_d_sgt.buf->data,
+					sign_d_sgt.length);
+	}
+
+	/*
+	 * Build the descriptor using Predifined ECC curve
+	 */
+	caam_desc_init(desc);
+	caam_desc_add_word(desc, DESC_HEADER(0));
+	caam_desc_add_word(desc, PDB_DSA_SIGN_N(n_bytes) |
+					 PDB_DSA_SIGN_L(l_bytes) |
+					 pdb_sgt_flags);
+	/* Prime number */
+	caam_desc_add_ptr(desc, dsakey.p.paddr);
+	/* Prime Modulus */
+	caam_desc_add_ptr(desc, dsakey.q.paddr);
+	/* Generator */
+	caam_desc_add_ptr(desc, dsakey.g.paddr);
+	/* Secret key */
+	caam_desc_add_ptr(desc, dsakey.x.paddr);
+	/* Input message */
+	caam_desc_add_ptr(desc, paddr_msg);
+	/* Signature 1st part */
+	caam_desc_add_ptr(desc, paddr_sign_c);
+	/* Signature 2nd part */
+	caam_desc_add_ptr(desc, paddr_sign_d);
+	/* Message length */
+	caam_desc_add_word(desc, sdata->message.length);
+
+	caam_desc_add_word(desc, DSA_SIGN(DL));
+
+	desclen = caam_desc_get_len(desc);
+	caam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));
+
+	ECC_DUMPDESC(desc);
+
+	jobctx.desc = desc;
+
+	retstatus = caam_jr_enqueue(&jobctx, NULL);
+	if (retstatus == CAAM_NO_ERROR) {
+		if (!sign_c_tmp.nocache)
+			cache_operation(TEE_CACHEINVALIDATE, sign_c_tmp.data,
+					sign_len);
+
+		if (realloc == 1)
+			memcpy(sdata->signature.data, sign_c_tmp.data,
+			       2 * sdata->size_sec);
+
+		sdata->signature.length = 2 * sdata->size_sec;
+
+		DSA_DUMPBUF("Signature", sdata->signature.data,
+			    sdata->signature.length);
+
+		ret = TEE_SUCCESS;
+	} else {
+		DSA_TRACE("CAAM Status 0x%08" PRIx32, jobctx.status);
+		ret = job_status_to_tee_result(jobctx.status);
+	}
+
+exit_sign:
+	caam_free_desc(&desc);
+	do_keypair_free(&dsakey);
+
+	if (realloc == 1) {
+		sign_c_tmp.length = sign_len;
+		caam_free_buf(&sign_c_tmp);
+	}
+
+	if (msg_sgt.sgt_type)
+		caam_sgtbuf_free(&msg_sgt);
+
+	if (sign_c_sgt.sgt_type)
+		caam_sgtbuf_free(&sign_c_sgt);
+
+	if (sign_d_sgt.sgt_type)
+		caam_sgtbuf_free(&sign_d_sgt);
+
+	return ret;
+}
+
+/*
+ * Verification of the Signature of DSA message
+ * Note the message is already hashed
+ *
+ * @sdata   [in/out] DSA Signature to verify
+ * @l_bytes  L bytes size (prime p size)
+ * @n_bytes  N bytes size (subprime q size)
+ */
+static TEE_Result do_verify(struct drvcrypt_sign_data *sdata, size_t l_bytes,
+			    size_t n_bytes)
+{
+	TEE_Result ret = TEE_ERROR_GENERIC;
+	enum caam_status retstatus = CAAM_FAILURE;
+	struct dsa_public_key *inkey = sdata->key;
+	struct caam_dsa_keypair dsakey = {};
+	struct caambuf tmp = {};
+	struct caam_jobctx jobctx = {};
+	uint32_t *desc = NULL;
+	uint32_t desclen = 0;
+	struct caambuf msg_tmp = {};
+	struct caamsgtbuf msg_sgt = { .sgt_type = false };
+	paddr_t paddr_msg = 0;
+	struct caambuf sign_c_tmp = {};
+	struct caambuf sign_d_tmp = {};
+	struct caamsgtbuf sign_c_sgt = { .sgt_type = false };
+	struct caamsgtbuf sign_d_sgt = { .sgt_type = false };
+	paddr_t paddr_sign_c = 0;
+	paddr_t paddr_sign_d = 0;
+	uint32_t pdb_sgt_flags = 0;
+
+#ifdef CFG_CAAM_64BIT
+#define MAX_DESC_VERIFY 21
+#else
+#define MAX_DESC_VERIFY 13
+#endif
+
+	DSA_TRACE("DSA Verify");
+
+	/* Allocate the job descriptor */
+	desc = caam_calloc_desc(MAX_DESC_VERIFY);
+	if (!desc) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_verify;
+	}
+
+	/* Convert the Public key to local key */
+	retstatus = do_keypub_conv(&dsakey, inkey, l_bytes, n_bytes);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_verify;
+	}
+
+	/* Prepare the input message CAAM Descriptor entry */
+	msg_tmp.data = sdata->message.data;
+	msg_tmp.length = sdata->message.length;
+	msg_tmp.paddr = virt_to_phys(sdata->message.data);
+	if (!caam_mem_is_cached_buf(sdata->message.data, sdata->message.length))
+		msg_tmp.nocache = 1;
+
+	retstatus = caam_sgt_build_block_data(&msg_sgt, NULL, &msg_tmp);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_GENERIC;
+		goto exit_verify;
+	}
+
+	if (msg_sgt.sgt_type) {
+		pdb_sgt_flags |= PDB_SGT_PKVERIF_MSG;
+		paddr_msg = virt_to_phys(msg_sgt.sgt);
+		caam_sgt_cache_op(TEE_CACHECLEAN, &msg_sgt);
+	} else {
+		paddr_msg = msg_sgt.buf->paddr;
+		if (!msg_sgt.buf->nocache)
+			cache_operation(TEE_CACHECLEAN, msg_sgt.buf->data,
+					msg_sgt.length);
+	}
+
+	/* Prepare the 1st Part of the signature */
+	sign_c_tmp.data = sdata->signature.data;
+	sign_c_tmp.length = l_bytes;
+	sign_c_tmp.paddr = virt_to_phys(sign_c_tmp.data);
+	if (!caam_mem_is_cached_buf(sdata->signature.data,
+				    sdata->signature.length))
+		sign_c_tmp.nocache = 1;
+
+	retstatus = caam_sgt_build_block_data(&sign_c_sgt, NULL, &sign_c_tmp);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_GENERIC;
+		goto exit_verify;
+	}
+
+	if (sign_c_sgt.sgt_type) {
+		pdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_C;
+		paddr_sign_c = virt_to_phys(sign_c_sgt.sgt);
+		caam_sgt_cache_op(TEE_CACHECLEAN, &sign_c_sgt);
+	} else {
+		paddr_sign_c = sign_c_sgt.buf->paddr;
+		if (!sign_c_sgt.buf->nocache)
+			cache_operation(TEE_CACHECLEAN, sign_c_sgt.buf->data,
+					sign_c_sgt.length);
+	}
+
+	/* Prepare the 2nd Part of the signature */
+	sign_d_tmp.data = sdata->signature.data + sdata->size_sec;
+	sign_d_tmp.length = sdata->size_sec;
+	sign_d_tmp.paddr = virt_to_phys(sign_d_tmp.data);
+	sign_d_tmp.nocache = sign_c_tmp.nocache;
+
+	retstatus = caam_sgt_build_block_data(&sign_d_sgt, NULL, &sign_d_tmp);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_GENERIC;
+		goto exit_verify;
+	}
+
+	if (sign_d_sgt.sgt_type) {
+		pdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_D;
+		paddr_sign_d = virt_to_phys(sign_d_sgt.sgt);
+		caam_sgt_cache_op(TEE_CACHECLEAN, &sign_d_sgt);
+	} else {
+		paddr_sign_d = sign_d_sgt.buf->paddr;
+		if (!sign_d_sgt.buf->nocache)
+			cache_operation(TEE_CACHECLEAN, sign_d_sgt.buf->data,
+					sign_d_sgt.length);
+	}
+
+	/* Allocate a Temporary buffer used by the CAAM */
+	retstatus = caam_alloc_align_buf(&tmp, l_bytes);
+	if (retstatus != CAAM_NO_ERROR) {
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_verify;
+	}
+
+	/*
+	 * Build the descriptor using Predifined ECC curve
+	 */
+	caam_desc_init(desc);
+	caam_desc_add_word(desc, DESC_HEADER(0));
+	caam_desc_add_word(desc, PDB_DSA_VERIF_N(n_bytes) |
+					 PDB_DSA_VERIF_L(l_bytes) |
+					 pdb_sgt_flags);
+	/* Prime number */
+	caam_desc_add_ptr(desc, dsakey.p.paddr);
+	/* Prime Modulus */
+	caam_desc_add_ptr(desc, dsakey.q.paddr);
+	/* Generator */
+	caam_desc_add_ptr(desc, dsakey.g.paddr);
+	/* Public key */
+	caam_desc_add_ptr(desc, dsakey.y.paddr);
+	/* Input message */
+	caam_desc_add_ptr(desc, paddr_msg);
+	/* Signature 1st part */
+	caam_desc_add_ptr(desc, paddr_sign_c);
+	/* Signature 2nd part */
+	caam_desc_add_ptr(desc, paddr_sign_d);
+	/* Temporary buffer */
+	caam_desc_add_ptr(desc, tmp.paddr);
+	/* Message length */
+	caam_desc_add_word(desc, sdata->message.length);
+
+	caam_desc_add_word(desc, DSA_VERIFY(DL));
+	desclen = caam_desc_get_len(desc);
+	caam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));
+
+	DSA_DUMPDESC(desc);
+
+	jobctx.desc = desc;
+
+	cache_operation(TEE_CACHEFLUSH, tmp.data, tmp.length);
+	retstatus = caam_jr_enqueue(&jobctx, NULL);
+
+	if (retstatus == CAAM_JOB_STATUS && !jobctx.status) {
+		DSA_TRACE("DSA Verify Status 0x%08" PRIx32, jobctx.status);
+		ret = TEE_ERROR_SIGNATURE_INVALID;
+	} else if (retstatus != CAAM_NO_ERROR) {
+		DSA_TRACE("CAAM Status 0x%08" PRIx32, jobctx.status);
+		ret = job_status_to_tee_result(jobctx.status);
+	} else {
+		ret = TEE_SUCCESS;
+	}
+
+exit_verify:
+	caam_free_desc(&desc);
+	do_keypair_free(&dsakey);
+	caam_free_buf(&tmp);
+
+	if (msg_sgt.sgt_type)
+		caam_sgtbuf_free(&msg_sgt);
+
+	if (sign_c_sgt.sgt_type)
+		caam_sgtbuf_free(&sign_c_sgt);
+
+	if (sign_d_sgt.sgt_type)
+		caam_sgtbuf_free(&sign_d_sgt);
+
+	return ret;
+}
+
+/*
+ * Registration of the DSA Driver
+ */
+static struct drvcrypt_dsa driver_dsa = {
+	.alloc_keypair = do_allocate_keypair,
+	.alloc_publickey = do_allocate_publickey,
+	.gen_keypair = do_gen_keypair,
+	.sign = do_sign,
+	.verify = do_verify,
+};
+
+enum caam_status caam_dsa_init(struct caam_jrcfg *caam_jrcfg)
+{
+	enum caam_status retstatus = CAAM_FAILURE;
+	vaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;
+
+	if (caam_hal_ctrl_pknum(jr_base))
+		if (drvcrypt_register_dsa(&driver_dsa) == TEE_SUCCESS)
+			retstatus = CAAM_NO_ERROR;
+
+	return retstatus;
+}
diff --git a/core/drivers/crypto/caam/acipher/caam_prime_dsa.c b/core/drivers/crypto/caam/acipher/caam_prime_dsa.c
new file mode 100644
index 00000000..216cacf9
--- /dev/null
+++ b/core/drivers/crypto/caam/acipher/caam_prime_dsa.c
@@ -0,0 +1,753 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright 2020 NXP
+ *
+ * CAAM DSA Prime Numbering.
+ * Implementation of Prime Number functions
+ */
+#include <caam_common.h>
+#include <caam_desc_ccb_defines.h>
+#include <caam_jr.h>
+#include <caam_utils_mem.h>
+#include <crypto/crypto.h>
+#include <kernel/panic.h>
+#include <mm/core_memprot.h>
+#include <string.h>
+#include <tee_api_types.h>
+#include <tee/cache.h>
+
+#include "local.h"
+
+#define PRIME_DESC_ENTRIES 62
+
+/* Define the number max of try to generate valid primes */
+#define DSA_MAX_TRIES_PRIME_Q 50000
+#define DSA_MAX_TRIES_PRIME_P 500
+
+#define DSA_TRY_FAIL	    0x42
+#define DSA_NOT_PRIME	    0x43
+#define DSA_PRIME_TOO_SMALL 0x44
+
+struct dsahash {
+	unsigned int op; /* CAAM Hash operation code */
+	size_t size;	 /* Hash digest size */
+};
+
+/*
+ * Build the descriptor generating a DSA prime Q
+ * Referring to FIPS.186-4, Section A.1.1.2 Generation of the
+ * Probable Primes p and q Using an Approved Hash Function
+ *
+ * @desc          [out] Descriptor built
+ * @seed          [out] Resulting seed used to generate prime
+ * @prime         [in/out] Prime generation data
+ * @hash_func     Selected Hash function
+ */
+static void do_desc_prime_q(uint32_t *desc, struct caambuf *seed,
+			    struct prime_dsa *prime, struct dsahash *hash_func)
+{
+	unsigned int desclen = 0;
+	unsigned int retry_new_mr_failed = 0;
+	unsigned int retry_mr_test = 0;
+
+	caam_desc_init(desc);
+	caam_desc_add_word(desc, DESC_HEADER(0));
+
+	/* Set the PKHA N and A register size */
+	caam_desc_add_word(desc, LD_IMM(CLASS_1, REG_PKHA_N_SIZE, 4));
+	caam_desc_add_word(desc, prime->q->length);
+	caam_desc_add_word(desc, LD_IMM(CLASS_1, REG_PKHA_A_SIZE, 4));
+	caam_desc_add_word(desc, prime->q->length);
+
+	caam_desc_add_word(desc, MATH(ADD, ZERO, IMM_DATA, VSOL, 4));
+	caam_desc_add_word(desc, DSA_MAX_TRIES_PRIME_Q);
+
+	caam_desc_add_word(desc, MATHI_OP1(SHIFT_L, ONE, 63, REG2, 8));
+
+	retry_new_mr_failed = caam_desc_get_len(desc);
+
+	/* Decrement the number of try */
+	caam_desc_add_word(desc, MATH(SUB, VSOL, ONE, VSOL, 4));
+	/* Exceed retry count - exit with DSA_TRY_FAIL error */
+	caam_desc_add_word(desc,
+			   HALT_USER(ALL_COND_TRUE, MATH_N, DSA_TRY_FAIL));
+
+	/* Clear Class 2 SHA */
+	caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_CLEAR_WRITTEN, 4));
+	caam_desc_add_word(desc, CLR_WR_RST_C2_CHA | CLR_WR_RST_C2_DSZ);
+
+	/*
+	 * Step 5. Generate Random Seed
+	 * Seed Length shall be equal or greater than N (Q prime length)
+	 * Seed result push in Message Data
+	 */
+	if (seed->length > 16) {
+		caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_NFIFO_n_SIZE, 4));
+		caam_desc_add_word(desc, NFIFO_PAD(BOTH, 0, MSG, RND, 16));
+
+		caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_NFIFO_n_SIZE, 4));
+		caam_desc_add_word(desc,
+				   NFIFO_PAD(BOTH, NFIFO_LC1 | NFIFO_LC2, MSG,
+					     RND, seed->length - 16));
+	} else {
+		caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_NFIFO_n_SIZE, 4));
+		caam_desc_add_word(desc, NFIFO_PAD(BOTH, NFIFO_LC1 | NFIFO_LC2,
+						   MSG, RND, seed->length));
+	}
+
+	caam_desc_add_word(desc, MOVE(C1_ALIGN, OFIFO, 0, seed->length));
+	caam_desc_add_word(desc, FIFO_ST(MSG_DATA, seed->length));
+	caam_desc_add_ptr(desc, seed->paddr);
+
+	/*
+	 * Hash the Seed, this is a pseudo U, bits upper N - 1 still present
+	 */
+	caam_desc_add_word(desc, HASH_INITFINAL(hash_func->op));
+
+	/*
+	 * Step 6. U = hash(seed) mod 2^(N-1)
+	 * Step 7. q = 2^(N-1) + U + 1 - (U mod 2)
+	 */
+	/* Trash the bits > N - 1, the hash size is >= N */
+	caam_desc_add_word(desc,
+			   MOVE_WAIT(C2_CTX_REG, MATH_REG0,
+				     hash_func->size - prime->q->length, 8));
+
+	/* Get the MSB of U and set the bit N-1 */
+	caam_desc_add_word(desc, MATH(OR, REG2, REG0, REG0, 8));
+
+	/* Move the candidate prime q's MSB into IFIFO */
+	caam_desc_add_word(desc, MOVE_WAIT(MATH_REG0, IFIFO, 0, 8));
+
+	/*
+	 * Move the candidate prime q's intermediate value into IFIFO
+	 */
+	caam_desc_add_word(desc,
+			   MOVE_WAIT(C2_CTX_REG, IFIFO,
+				     hash_func->size - prime->q->length + 8,
+				     prime->q->length - 16));
+
+	/* Get the LSB of U and set the bit 0 */
+	caam_desc_add_word(desc, MOVE_WAIT(C2_CTX_REG, MATH_REG0,
+					   hash_func->size - 8, 8));
+	caam_desc_add_word(desc, MATH(OR, ONE, REG0, REG0, 8));
+
+	/* Move the candidate prime q's LSB into IFIFO */
+	caam_desc_add_word(desc, MOVE_WAIT(MATH_REG0, IFIFO, 0, 8));
+
+	/* Move the IFIFO in to PKHA N */
+	caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_NFIFO, 8));
+	caam_desc_add_word(desc, NFIFO_NOPAD(C1, NFIFO_FC1, IFIFO, PKHA_N, 0));
+	caam_desc_add_word(desc, prime->q->length);
+
+	/* Store the Prime q here because Miller-Rabin test affect PKHA N */
+	caam_desc_add_word(desc, FIFO_ST(PKHA_N, prime->q->length));
+	caam_desc_add_ptr(desc, prime->q->paddr);
+
+	/*
+	 * Step 8. Test q prime with 'miller-rabin' test
+	 */
+	/* Load the number of Miller-Rabin test iteration */
+	caam_desc_add_word(desc, MATH(ADD, IMM_DATA, ZERO, SIL, 4));
+	if (prime->p->length <= 1024 / 8)
+		caam_desc_add_word(desc, 40);
+	else if (prime->p->length >= 3072 / 8)
+		caam_desc_add_word(desc, 64);
+	else
+		caam_desc_add_word(desc, 56);
+
+	retry_mr_test = caam_desc_get_len(desc);
+	/* Generate 8 random bytes 'miller-rabin seed' */
+	caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_NFIFO, 8));
+	caam_desc_add_word(desc, NFIFO_PAD(C1, NFIFO_FC1, PKHA_A, RND, 0));
+	caam_desc_add_word(desc, prime->q->length);
+	caam_desc_add_word(desc, FIFO_LD_IMM(CLASS_1, PKHA_B, NOACTION, 1));
+	caam_desc_add_word(desc, 0x01);
+	caam_desc_add_word(desc, PKHA_OP(MR_PRIMER_TEST, B));
+
+	desclen = caam_desc_get_len(desc);
+
+	/*
+	 * Step 9. If q is not q prime back to step 5
+	 */
+	caam_desc_add_word(desc, JUMP_CNO_LOCAL(ANY_COND_FALSE,
+						JMP_COND(PKHA_IS_PRIME),
+						retry_new_mr_failed - desclen));
+	caam_desc_add_word(desc, MATH(SUB, SIL, ONE, SIL, 4));
+
+	desclen = caam_desc_get_len(desc);
+	/* Test while number of MR test iteration not complete */
+	caam_desc_add_word(desc,
+			   JUMP_CNO_LOCAL(ALL_COND_FALSE,
+					  JMP_COND(MATH_N) | JMP_COND(MATH_Z),
+					  retry_mr_test - desclen));
+	DSA_TRACE("Prime Q descriptor");
+	DSA_DUMPDESC(desc);
+}
+
+/*
+ * Build the descriptor generating the intermediate value X (step 11.3)
+ * Referring to FIPS.186-4, Section A.1.1.2 Generation of the
+ * Probable Primes p and q Using an Approved Hash Function
+ *
+ * @desc        [out] Descriptor built
+ * @x           [out] Value X
+ * @seed        [in/out] Seed to hash and next seed for next loop
+ * @prime       [in/out] Prime generation data
+ * @hash_func   Selected Hash function
+ * @mod_n       Modular value (0xFF filled buffer)
+ * @desc_p      Physical address of the descriptor doing Prime P
+ */
+static void do_desc_gen_x(uint32_t *desc, struct caambuf *x,
+			  struct caambuf *seed, struct prime_dsa *prime,
+			  struct dsahash *hash_func, struct caambuf *mod_n,
+			  paddr_t desc_p)
+{
+	unsigned int desclen = 0;
+	unsigned int loop_n = 0;
+	size_t n = 0;
+	size_t b = 0;
+	size_t b_offset = 0;
+
+	/*
+	 * Step 3. n = ceil(L / outlen) - 1
+	 * where outlen is the hash size in bits
+	 *
+	 * Note build descriptor with n = ceil(L / outlen) to
+	 * pre-calculate seed for next run.
+	 */
+	n = (prime->p->length + hash_func->size) * 8 - 1;
+	n /= hash_func->size * 8;
+
+	/*
+	 * Step 4. b = L - 1 - (n  * outlen)
+	 *
+	 * Note b determine the number of bits to keep in the last
+	 * Vn computed.
+	 * Calculate b_offset which is the offset in bytes to remove from
+	 * the calculated hash
+	 */
+	b = prime->p->length * 8 - 1 - (n - 1) * hash_func->size * 8;
+
+	DSA_TRACE("Prime p => n = %zu | b = %zu", n - 1, b);
+	b_offset = hash_func->size - (b + 1) / 8;
+	DSA_TRACE("Vn offset is %zu", b_offset);
+
+	caam_desc_init(desc);
+	caam_desc_add_word(desc, DESC_HEADER(0));
+
+	caam_desc_add_word(desc, SEQ_OUT_PTR(x->length));
+	caam_desc_add_ptr(desc, x->paddr);
+
+	caam_desc_add_word(desc, MATHI_OP1(SHIFT_L, ONE, 63, REG2, 8));
+
+	caam_desc_add_word(desc, MATH(ADD, ZERO, IMM_DATA, REG0, 4));
+	caam_desc_add_word(desc, n);
+
+	caam_desc_add_word(desc,
+			   FIFO_LD(CLASS_1, PKHA_N, NOACTION, seed->length));
+	caam_desc_add_ptr(desc, mod_n->paddr);
+
+	/*
+	 * Because the Sequence Out Pointer is incremental store, we need
+	 * to build w number in reverse.
+	 *
+	 * Hence, calculate the last seed number of the loop and save it.
+	 * Step 11.9 is automatically done here by incrementing seed number.
+	 */
+	caam_desc_add_word(desc, FIFO_LD_IMM(CLASS_1, PKHA_B, NOACTION, 1));
+	caam_desc_add_word(desc, n);
+	caam_desc_add_word(desc,
+			   FIFO_LD(CLASS_1, PKHA_A, NOACTION, seed->length));
+	caam_desc_add_ptr(desc, seed->paddr);
+	caam_desc_add_word(desc, PKHA_OP(MOD_ADD_A_B, A));
+	caam_desc_add_word(desc, FIFO_ST(PKHA_A, seed->length));
+	caam_desc_add_ptr(desc, seed->paddr);
+
+	caam_desc_add_word(desc, PKHA_CPY_NSIZE(A0, B1));
+	caam_desc_add_word(desc, FIFO_LD_IMM(CLASS_1, PKHA_B, NOACTION, 1));
+	caam_desc_add_word(desc, 1);
+
+	caam_desc_add_word(desc, WAIT_COND(ALL_COND_TRUE, NIFP));
+
+	/*
+	 * Step 11.1
+	 * For j = 0 to n do
+	 *    Vj = hash((seed + offset + j) mod 2^seedlen
+	 * Step 11.2
+	 *    W = V0 + (V1 * 2^outlen) + ... +
+	 *        (Vn-1 * 2^((n-1)*outlen)) +
+	 *        ((Vn mod 2^b) * 2^(n*outlen))
+	 */
+	loop_n = caam_desc_get_len(desc);
+
+	caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_CLEAR_WRITTEN, 4));
+	caam_desc_add_word(desc, CLR_WR_IFIFO_NFIFO | CLR_WR_RST_C2_CHA |
+					 CLR_WR_RST_C2_DSZ);
+
+	caam_desc_add_word(desc, HASH_INITFINAL(hash_func->op));
+	caam_desc_add_word(desc, LD_NOCLASS_IMM(REG_CHA_CTRL, 4));
+	caam_desc_add_word(desc, CCTRL_ULOAD_PKHA_A);
+
+	caam_desc_add_word(desc,
+			   MOVE_WAIT(OFIFO, IFIFO_C2_LC2, 0, seed->length));
+
+	/* If Math Register 2 is zero bypass the high bit set to one */
+	caam_desc_add_word(desc, MATH(SUB, REG2, ONE, NODEST, 8));
+	caam_desc_add_word(desc,
+			   JUMP_CNO_LOCAL(ANY_COND_TRUE,
+					  JMP_COND(MATH_N) | JMP_COND(MATH_Z),
+					  8));
+	/*
+	 * Step 11.3
+	 * X = W + 2^(L-1)
+	 */
+	/*
+	 * Set the high bit to one
+	 * Remark: the DSA key is a modulus 8 bytes, hence no need
+	 *         to check if the b_offset is less than 8.
+	 */
+	caam_desc_add_word(desc, MOVE_WAIT(C2_CTX_REG, MATH_REG1, b_offset, 8));
+	caam_desc_add_word(desc, MATH(OR, REG2, REG1, REG1, 8));
+	caam_desc_add_word(desc, MOVE(MATH_REG1, OFIFO, 0, 8));
+
+	if (hash_func->size - b_offset > 8)
+		caam_desc_add_word(desc,
+				   MOVE_WAIT(C2_CTX_REG, OFIFO, b_offset + 8,
+					     hash_func->size - b_offset - 8));
+	caam_desc_add_word(desc,
+			   FIFO_ST_SEQ(MSG_DATA, hash_func->size - b_offset));
+
+	/*
+	 * Reset MATH Register 2 to bypass the High Bit set
+	 * operation next loop
+	 */
+	caam_desc_add_word(desc, MATH(AND, REG2, ZERO, REG2, 8));
+
+	caam_desc_add_word(desc,
+			   JUMP_CNO_LOCAL(ALL_COND_TRUE, JMP_COND(NONE), 2));
+
+	/* Bypass High Bit set */
+	caam_desc_add_word(desc,
+			   ST_NOIMM_SEQ(CLASS_2, REG_CTX, hash_func->size));
+
+	caam_desc_add_word(desc, PKHA_CPY_NSIZE(B1, A0));
+	caam_desc_add_word(desc, PKHA_OP(MOD_SUB_A_B, A));
+	caam_desc_add_word(desc, PKHA_CPY_NSIZE(A0, B1));
+
+	desclen = caam_desc_get_len(desc);
+	caam_desc_add_word(desc, JUMP_CNO_LOCAL_DEC(ALL_COND_FALSE, MATH_0,
+						    JMP_COND_MATH(N) |
+							    JMP_COND_MATH(Z),
+						    loop_n - desclen));
+	/* Jump to the next descriptor desc */
+	caam_desc_add_word(desc, JUMP_NOTLOCAL(CLASS_NO, ALL_COND_TRUE,
+					       JMP_COND(NONE)));
+	caam_desc_add_ptr(desc, desc_p);
+
+	DSA_TRACE("X descriptor");
+	DSA_DUMPDESC(desc);
+}
+
+/*
+ * Build the descriptor generating the Prime P from value X
+ * Referring to FIPS.186-4, Section A.1.1.2 Generation of the
+ * Probable Primes p and q Using an Approved Hash Function
+ *
+ * @desc        [out] Descriptor built
+ * @prime       [in/out] Prime generation data
+ * @x           Value X
+ * @mod_n       Modular value (0xFF filled buffer)
+ */
+static void do_desc_prime_p(uint32_t *desc, struct prime_dsa *prime,
+			    struct caambuf *x, struct caambuf *mod_n)
+{
+	unsigned int desclen = 0;
+	unsigned int retry_mr_test = 0;
+	size_t index = 0;
+
+	caam_desc_init(desc);
+	caam_desc_add_word(desc, DESC_HEADER(0));
+
+	caam_desc_add_word(desc,
+			   FIFO_LD(CLASS_1, PKHA_N, NOACTION, mod_n->length));
+	caam_desc_add_ptr(desc, mod_n->paddr);
+
+	/*
+	 * Step 11.4
+	 * c = X mod 2q
+	 */
+
+	/* Calculate 2q and store it in PKHA N */
+	caam_desc_add_word(desc, FIFO_LD(CLASS_1, PKHA_A, NOACTION,
+					 prime->q->length));
+	caam_desc_add_ptr(desc, prime->q->paddr);
+	caam_desc_add_word(desc, PKHA_CPY_SSIZE(A0, B0));
+	caam_desc_add_word(desc, PKHA_OP(MOD_ADD_A_B, A));
+
+	caam_desc_add_word(desc, PKHA_CPY_SSIZE(A0, N0));
+
+	/* c = X mod 2q */
+	caam_desc_add_word(desc, FIFO_LD(CLASS_1, PKHA_A, NOACTION, x->length));
+	caam_desc_add_ptr(desc, x->paddr);
+	caam_desc_add_word(desc,
+			   JUMP_CNO_LOCAL(ALL_COND_TRUE, JMP_COND(NIFP), 1) |
+				   BIT(24));
+	caam_desc_add_word(desc, PKHA_OP(MOD_AMODN, A));
+
+	/*
+	 * Step 11.5
+	 * p = X - (c - 1)
+	 */
+	caam_desc_add_word(desc,
+			   FIFO_LD(CLASS_1, PKHA_N, NOACTION, mod_n->length));
+	caam_desc_add_ptr(desc, mod_n->paddr);
+
+	caam_desc_add_word(desc, FIFO_LD_IMM(CLASS_1, PKHA_B, NOACTION, 1));
+	caam_desc_add_ptr(desc, 1);
+	caam_desc_add_word(desc, PKHA_OP(MOD_SUB_A_B, B));
+
+	caam_desc_add_word(desc, FIFO_LD(CLASS_1, PKHA_A, NOACTION, x->length));
+	caam_desc_add_ptr(desc, x->paddr);
+	caam_desc_add_word(desc, PKHA_OP(MOD_SUB_A_B, A));
+
+	/*
+	 * Save the candidate Prime q now because N is going to be
+	 * affected by the Miller-Rabin test
+	 */
+	caam_desc_add_word(desc, PKHA_CPY_SSIZE(A0, N0));
+	caam_desc_add_word(desc, FIFO_ST(PKHA_N, prime->p->length));
+	caam_desc_add_ptr(desc, prime->p->paddr);
+	caam_desc_add_word(desc, FIFO_ST_SEQ(MSG_DATA, 0));
+
+	/*
+	 * Step 11.6
+	 * if (p < 2^(L-1)) then go to step 11.9
+	 *
+	 */
+	caam_desc_add_word(desc, LD_NOCLASS_IMM(REG_CHA_CTRL, 4));
+	caam_desc_add_word(desc, CCTRL_ULOAD_PKHA_A);
+
+	/* Keep the MSB from p candidate and check if bit 2^(L-1) is set */
+	caam_desc_add_word(desc, MOVE_WAIT(OFIFO, MATH_REG0, 0, 8));
+	for (index = 1; index < prime->p->length / 128; index++)
+		caam_desc_add_word(desc, MOVE(OFIFO, C1_CTX_REG, 0, 128));
+
+	caam_desc_add_word(desc, MOVE(OFIFO, C1_CTX_REG, 0, 124));
+
+	caam_desc_add_word(desc, MATHI_OP1(SHIFT_L, ONE, 63, REG2, 8));
+	caam_desc_add_word(desc, MATH(AND, REG0, REG2, REG0, 8));
+
+	caam_desc_add_word(desc, HALT_USER(ALL_COND_TRUE, MATH_Z,
+					   DSA_PRIME_TOO_SMALL));
+
+	/*
+	 * Step 11.7
+	 * Test whether or not p is prime
+	 */
+
+	/*
+	 * Referring to FIPS.186-4, Table C.1
+	 * Get the number Miller-Rabin test interation function
+	 * of the prime number size
+	 */
+	caam_desc_add_word(desc, MATH(ADD, IMM_DATA, ZERO, REG0, 4));
+	if (prime->p->length <= 1024 / 8)
+		caam_desc_add_word(desc, 40);
+	else if (prime->p->length >= 3072 / 8)
+		caam_desc_add_word(desc, 64);
+	else
+		caam_desc_add_word(desc, 56);
+
+	retry_mr_test = caam_desc_get_len(desc);
+	/* Generate 8 random bytes 'miller-rabin seed' */
+	caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_NFIFO, 8));
+	caam_desc_add_word(desc, NFIFO_PAD(C1, NFIFO_FC1, PKHA_A, RND, 0));
+	caam_desc_add_word(desc, prime->p->length);
+	caam_desc_add_word(desc, FIFO_LD_IMM(CLASS_1, PKHA_B, NOACTION, 1));
+	caam_desc_add_word(desc, 0x01);
+	caam_desc_add_word(desc, PKHA_OP(MR_PRIMER_TEST, B));
+
+	desclen = caam_desc_get_len(desc);
+
+	/*
+	 * Step 11.8
+	 * if p is not a prime continue to step 11.9
+	 */
+	caam_desc_add_word(desc, HALT_USER(ALL_COND_FALSE, PKHA_IS_PRIME,
+					   DSA_NOT_PRIME));
+
+	desclen = caam_desc_get_len(desc);
+	/* Test while number of MR test iteration not complete */
+	caam_desc_add_word(desc, JUMP_CNO_LOCAL_DEC(ALL_COND_FALSE, MATH_0,
+						    JMP_COND_MATH(N) |
+							    JMP_COND_MATH(Z),
+						    retry_mr_test - desclen));
+
+	DSA_TRACE("Prime P descriptor");
+	DSA_DUMPDESC(desc);
+
+	/*
+	 * Ensure descriptor is pushed in physical memory because it's
+	 * called from another descriptor.
+	 */
+	cache_operation(TEE_CACHECLEAN, desc, DESC_SZBYTES(PRIME_DESC_ENTRIES));
+}
+
+/*
+ * Run the Prime Q descriptor.
+ *
+ * @desc Descriptor built
+ */
+static enum caam_status run_prime_q(uint32_t *desc, struct prime_dsa *prime)
+{
+	enum caam_status retstatus = CAAM_FAILURE;
+	struct caam_jobctx jobctx = {};
+
+	cache_operation(TEE_CACHEFLUSH, prime->q->data, prime->q->length);
+
+	jobctx.desc = desc;
+	retstatus = caam_jr_enqueue(&jobctx, NULL);
+
+	if (retstatus != CAAM_NO_ERROR) {
+		DSA_TRACE("Prime Q Status 0x%08" PRIx32 " ret 0x%08" PRIx32,
+			  jobctx.status, retstatus);
+		retstatus = CAAM_FAILURE;
+	} else {
+		cache_operation(TEE_CACHEINVALIDATE, prime->q->data,
+				prime->q->length);
+		DSA_DUMPBUF("Prime Q", prime->q->data, prime->q->length);
+	}
+
+	return retstatus;
+}
+
+/*
+ * Run the Prime P descriptors.
+ *
+ * @desc   Descriptor built
+ * @prime  Prime generation data
+ */
+static enum caam_status run_prime_p(uint32_t *desc, struct prime_dsa *prime)
+{
+	enum caam_status retstatus = CAAM_FAILURE;
+	struct caam_jobctx jobctx = {};
+	size_t counter = 0;
+
+	cache_operation(TEE_CACHEFLUSH, prime->p->data, prime->p->length);
+
+	jobctx.desc = desc;
+	for (counter = 0; counter < 4 * prime->p->length * 8; counter++) {
+		retstatus = caam_jr_enqueue(&jobctx, NULL);
+
+		if (retstatus == CAAM_NO_ERROR) {
+			DSA_TRACE("Prime P try: counter=%zu", counter);
+			cache_operation(TEE_CACHEINVALIDATE, prime->p->data,
+					prime->p->length);
+			DSA_DUMPBUF("Prime P", prime->p->data,
+				    prime->p->length);
+
+			return retstatus;
+		}
+
+		if (retstatus == CAAM_JOB_STATUS) {
+			if (JRSTA_GET_HALT_USER(jobctx.status) !=
+				    DSA_NOT_PRIME &&
+			    JRSTA_GET_HALT_USER(jobctx.status) !=
+				    DSA_PRIME_TOO_SMALL) {
+				DSA_TRACE("Prime P status 0x%08" PRIx32,
+					  jobctx.status);
+				return CAAM_FAILURE;
+			}
+		}
+	}
+
+	/* This is not a prime, will try with another prime q */
+	return CAAM_BAD_PARAM;
+}
+
+/*
+ * Generate the DSA parameter G (generator)
+ * Referring to FIPS.186-4, Section A.2.1 Unverifiable Generation of the
+ * Generator g
+ *
+ * @desc        Descriptor buffer to use
+ * @prime       [in/out] Prime generation data
+ * @mod_n       Modular value (0xFF filled buffer)
+ */
+static enum caam_status do_generator(uint32_t *desc, struct prime_dsa *prime,
+				     struct caambuf *mod_n)
+{
+	enum caam_status retstatus = CAAM_FAILURE;
+	struct caam_jobctx jobctx = {};
+	unsigned int desclen = 0;
+	unsigned int retry_new_h = 0;
+
+	caam_desc_init(desc);
+	caam_desc_add_word(desc, DESC_HEADER(0));
+
+	caam_desc_add_word(desc,
+			   FIFO_LD(CLASS_1, PKHA_N, NOACTION, mod_n->length));
+	caam_desc_add_ptr(desc, mod_n->paddr);
+
+	/*
+	 * Step 1.
+	 * e = (p - 1)/q
+	 */
+	caam_desc_add_word(desc, FIFO_LD(CLASS_1, PKHA_A, NOACTION,
+					 prime->p->length));
+	caam_desc_add_ptr(desc, prime->p->paddr);
+	caam_desc_add_word(desc, FIFO_LD_IMM(CLASS_1, PKHA_B, NOACTION, 1));
+	caam_desc_add_ptr(desc, 1);
+	/* PKHA B = (p - 1) */
+	caam_desc_add_word(desc, PKHA_OP(MOD_SUB_A_B, B));
+
+	caam_desc_add_word(desc, FIFO_LD(CLASS_1, PKHA_A, NOACTION,
+					 prime->q->length));
+	caam_desc_add_ptr(desc, prime->q->paddr);
+	/* PKHA A = 1/q */
+	caam_desc_add_word(desc, PKHA_OP(MOD_INV_A, A));
+
+	/* PKHA E = (p - 1)/q */
+	caam_desc_add_word(desc, PKHA_OP(MOD_MUL_A_B, A));
+	caam_desc_add_word(desc, PKHA_CPY_SSIZE(A0, E));
+
+	/* Load N with prime p */
+	caam_desc_add_word(desc, FIFO_LD(CLASS_1, PKHA_N, NOACTION,
+					 prime->p->length));
+	caam_desc_add_ptr(desc, prime->p->paddr);
+
+	/*
+	 * Step 2. Generate a Random h
+	 * where 1 < h < (p - 1)
+	 *
+	 * To ensure h < (p - 1), generate a random of p length - 2
+	 */
+	retry_new_h = caam_desc_get_len(desc);
+	caam_desc_add_word(desc, LD_IMM(CLASS_NO, REG_NFIFO, 8));
+	caam_desc_add_word(desc, NFIFO_PAD(C1, NFIFO_FC1, PKHA_A, RND, 0));
+	caam_desc_add_word(desc, prime->p->length - 2);
+
+	/*
+	 * Step 3.
+	 * g = h^e mod p
+	 */
+	caam_desc_add_word(desc, PKHA_OP(MOD_EXP_A_E, A));
+
+	/*
+	 * Step 4.
+	 * if (g = 1) then go to step 2
+	 */
+	desclen = caam_desc_get_len(desc);
+	caam_desc_add_word(desc,
+			   JUMP_CNO_LOCAL(ALL_COND_TRUE, JMP_COND(PKHA_GCD_1),
+					  retry_new_h - desclen));
+
+	/* g is good save it */
+	caam_desc_add_word(desc, FIFO_ST(PKHA_A, prime->g->length));
+	caam_desc_add_ptr(desc, prime->g->paddr);
+
+	DSA_DUMPDESC(desc);
+
+	cache_operation(TEE_CACHEFLUSH, prime->g->data, prime->g->length);
+
+	jobctx.desc = desc;
+	retstatus = caam_jr_enqueue(&jobctx, NULL);
+
+	if (retstatus != CAAM_NO_ERROR) {
+		DSA_TRACE("Generator G Status 0x%08" PRIx32 " ret 0x%08" PRIx32,
+			  jobctx.status, retstatus);
+		return CAAM_FAILURE;
+	}
+
+	cache_operation(TEE_CACHEINVALIDATE, prime->g->data, prime->g->length);
+	DSA_DUMPBUF("Generator G", prime->g->data, prime->g->length);
+	return CAAM_NO_ERROR;
+}
+
+enum caam_status caam_prime_dsa_gen(struct prime_dsa *data)
+{
+	enum caam_status retstatus = CAAM_FAILURE;
+	uint32_t *desc_all = NULL;
+	uint32_t *desc_q = NULL;
+	uint32_t *desc_x = NULL;
+	uint32_t *desc_p = NULL;
+	struct caambuf seed = {};
+	struct caambuf mod_n = {};
+	struct dsahash hash_func = { OP_ALGO(SHA256), TEE_SHA256_HASH_SIZE };
+	size_t nb_tries = DSA_MAX_TRIES_PRIME_P;
+	struct caambuf x = {};
+
+	/*
+	 * For the now as the DSA Prime p size is limited to 3072, Prime q
+	 * is also limited to 256. Hence the hash function to use is
+	 * SHA-256.
+	 * Ensure here that limit is not crossed because on some i.MX device
+	 * hash is limited to 256.
+	 */
+	if (data->q->length > 256)
+		return CAAM_BAD_PARAM;
+
+	retstatus = caam_calloc_buf(&mod_n, data->p->length);
+	if (retstatus != CAAM_NO_ERROR)
+		goto end_gen_prime;
+
+	memset(mod_n.data, 0xFF, mod_n.length);
+	cache_operation(TEE_CACHECLEAN, mod_n.data, mod_n.length);
+
+	retstatus = caam_calloc_align_buf(&seed, data->q->length);
+	if (retstatus != CAAM_NO_ERROR)
+		return retstatus;
+
+	retstatus = caam_calloc_buf(&x, data->p->length);
+	if (retstatus != CAAM_NO_ERROR)
+		return retstatus;
+
+	desc_all = caam_calloc_desc(PRIME_DESC_ENTRIES * 3);
+	if (!desc_all) {
+		retstatus = CAAM_OUT_MEMORY;
+		goto end_gen_prime;
+	}
+
+	DSA_TRACE("Do primes P %zu bytes, Q %zu bytes", data->p->length,
+		  data->q->length);
+
+	desc_q = desc_all;
+	desc_x = desc_q + PRIME_DESC_ENTRIES;
+	desc_p = desc_x + PRIME_DESC_ENTRIES;
+
+	do_desc_prime_q(desc_q, &seed, data, &hash_func);
+	do_desc_gen_x(desc_x, &x, &seed, data, &hash_func, &mod_n,
+		      virt_to_phys(desc_p));
+	do_desc_prime_p(desc_p, data, &x, &mod_n);
+
+	cache_operation(TEE_CACHEFLUSH, data->p->data, data->p->length);
+	cache_operation(TEE_CACHEFLUSH, seed.data, seed.length);
+	cache_operation(TEE_CACHEFLUSH, x.data, x.length);
+
+	for (; nb_tries > 0; nb_tries--) {
+		retstatus = run_prime_q(desc_q, data);
+
+		if (retstatus == CAAM_NO_ERROR) {
+			retstatus = run_prime_p(desc_x, data);
+			if (retstatus == CAAM_NO_ERROR)
+				break;
+		}
+
+		if (retstatus == CAAM_FAILURE) {
+			DSA_TRACE("DSA Prime P/Q Generation failed");
+			break;
+		}
+	}
+
+	if (retstatus == CAAM_NO_ERROR)
+		retstatus = do_generator(desc_all, data, &mod_n);
+
+end_gen_prime:
+	caam_free_desc(&desc_all);
+	caam_free_buf(&seed);
+	caam_free_buf(&x);
+	caam_free_buf(&mod_n);
+
+	return retstatus;
+}
diff --git a/core/drivers/crypto/caam/acipher/local.h b/core/drivers/crypto/caam/acipher/local.h
index 03569108..90de811f 100644
--- a/core/drivers/crypto/caam/acipher/local.h
+++ b/core/drivers/crypto/caam/acipher/local.h
@@ -28,4 +28,21 @@ struct prime_rsa {
  */
 enum caam_status caam_prime_rsa_gen(struct prime_rsa *data);
 
+/*
+ * Prime generator structure for DSA
+ */
+struct prime_dsa {
+	struct caambuf *g; /* Generator g */
+	struct caambuf *p; /* Prime p */
+	struct caambuf *q; /* Prime q */
+};
+
+/*
+ * Generate DSA Prime Number
+ * Algorithm based on the Chapter A.1.2 of the FIPS.186-4 specification
+ *
+ * @data  [in/out] Prime generation data
+ */
+enum caam_status caam_prime_dsa_gen(struct prime_dsa *data);
+
 #endif /* __LOCAL_H__ */
diff --git a/core/drivers/crypto/caam/acipher/sub.mk b/core/drivers/crypto/caam/acipher/sub.mk
index 05a56109..ea806000 100644
--- a/core/drivers/crypto/caam/acipher/sub.mk
+++ b/core/drivers/crypto/caam/acipher/sub.mk
@@ -2,5 +2,6 @@ incdirs-y += ../include
 
 srcs-$(CFG_NXP_CAAM_ECC_DRV) += caam_ecc.c
 srcs-$(CFG_NXP_CAAM_RSA_DRV) += caam_rsa.c caam_prime_rsa.c
+srcs-$(CFG_NXP_CAAM_DSA_DRV) += caam_dsa.c caam_prime_dsa.c
 srcs-$(CFG_NXP_CAAM_DH_DRV)  += caam_dh.c
 srcs-y += caam_math.c
diff --git a/core/drivers/crypto/caam/caam_ctrl.c b/core/drivers/crypto/caam/caam_ctrl.c
index bb502edd..139696cc 100644
--- a/core/drivers/crypto/caam/caam_ctrl.c
+++ b/core/drivers/crypto/caam/caam_ctrl.c
@@ -132,6 +132,13 @@ TEE_Result crypto_driver_init(void)
 		goto exit_init;
 	}
 
+	/* Initialize the DSA Module */
+	retstatus = caam_dsa_init(&jrcfg);
+	if (retstatus != CAAM_NO_ERROR) {
+		retresult = TEE_ERROR_GENERIC;
+		goto exit_init;
+	}
+
 	/* Everything is OK, register the Power Management handler */
 	caam_pwr_init();
 
diff --git a/core/drivers/crypto/caam/include/caam_acipher.h b/core/drivers/crypto/caam/include/caam_acipher.h
index b96c3467..b19b79f0 100644
--- a/core/drivers/crypto/caam/include/caam_acipher.h
+++ b/core/drivers/crypto/caam/include/caam_acipher.h
@@ -8,6 +8,7 @@
 #define __CAAM_ACIPHER_H__
 
 #include <caam_common.h>
+#include <caam_jr.h>
 
 #ifdef CFG_NXP_CAAM_ECC_DRV
 /*
@@ -51,6 +52,21 @@ static inline enum caam_status caam_dh_init(vaddr_t ctrl_addr __unused)
 }
 #endif /* CFG_NXP_CAAM_DH_DRV */
 
+#ifdef CFG_NXP_CAAM_DSA_DRV
+/*
+ * Initialize the DSA module
+ *
+ * @caam_jrcfg   CAAM job ring configuration
+ */
+enum caam_status caam_dsa_init(struct caam_jrcfg *caam_jrcfg);
+#else
+static inline enum caam_status
+caam_dsa_init(struct caam_jrcfg *caam_jrcfg __unused)
+{
+	return CAAM_NO_ERROR;
+}
+#endif /* CFG_NXP_CAAM_DSA_DRV */
+
 #ifdef CFG_NXP_CAAM_ACIPHER_DRV
 /*
  * Initialize the MATH module
diff --git a/core/drivers/crypto/caam/include/caam_desc_ccb_defines.h b/core/drivers/crypto/caam/include/caam_desc_ccb_defines.h
index 9cd63fd3..a2f5dc32 100644
--- a/core/drivers/crypto/caam/include/caam_desc_ccb_defines.h
+++ b/core/drivers/crypto/caam/include/caam_desc_ccb_defines.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: BSD-2-Clause */
 /*
- * Copyright 2018-2019 NXP
+ * Copyright 2018-2020 NXP
  *
  * Brief   Define the CCB Registers to use in the CAAM descriptor
  */
@@ -9,12 +9,20 @@
 
 /* CCB CHA Control Register */
 #define CCTRL_ULOAD_PKHA_B  BIT32(27)
+#define CCTRL_ULOAD_PKHA_A  BIT32(26)
+
+/* CCB Clear Written Register */
+#define CLR_WR_IFIFO_NFIFO BIT32(31)
+#define CLR_WR_RST_C2_CHA  BIT32(28)
+#define CLR_WR_RST_C2_DSZ  BIT32(18)
 
 /* CCB NFIFO */
 #define NFIFO_CLASS(cla)       SHIFT_U32(NFIFO_CLASS_##cla & 0x3, 30)
 #define NFIFO_CLASS_DECO       0x0
 #define NFIFO_CLASS_C1         0x1
+#define NFIFO_CLASS_BOTH       0x3
 
+#define NFIFO_LC2	       BIT32(29)
 #define NFIFO_LC1              BIT32(28)
 #define NFIFO_FC1              BIT32(26)
 
diff --git a/core/drivers/crypto/caam/include/caam_desc_defines.h b/core/drivers/crypto/caam/include/caam_desc_defines.h
index 54a7dc3e..2972a6a2 100644
--- a/core/drivers/crypto/caam/include/caam_desc_defines.h
+++ b/core/drivers/crypto/caam/include/caam_desc_defines.h
@@ -73,6 +73,7 @@
  * STORE Command fields
  */
 #define CMD_STORE_TYPE		CMD_TYPE(0x0A)
+#define CMD_STORE_SEQ_TYPE	CMD_TYPE(0x0B)
 
 /* Store Source */
 #define STORE_SRC(reg)		SHIFT_U32((reg) & 0x7F, 16)
@@ -178,6 +179,7 @@
  * FIFO STORE Command fields
  */
 #define CMD_FIFO_STORE_TYPE	CMD_TYPE(0x0C)
+#define CMD_SEQ_FIFO_STORE_TYPE CMD_TYPE(0x0D)
 
 /* Extended Length */
 #define FIFO_STORE_EXT		BIT32(22)
@@ -247,8 +249,8 @@
 #define MOVE_SRC_MATH_REG2		MOVE_REG_SRC(0x6)
 #define MOVE_SRC_MATH_REG3		MOVE_REG_SRC(0x7)
 #define MOVE_SRC_NFIFO_DECO_ALIGN	MOVE_REG_SRC(0x8)
-#define MOVE_SRC_NFIFO_C1_ALIGN		(MOVE_REG_SRC(0x9) | MOVE_AUX(0x0))
-#define MOVE_SRC_NFIFO_C2_ALIGN		(MOVE_REG_SRC(0x9) | MOVE_AUX(0x1))
+#define MOVE_SRC_NFIFO_C1_ALIGN		(MOVE_REG_SRC(0x9) | MOVE_AUX(0x1))
+#define MOVE_SRC_NFIFO_C2_ALIGN		(MOVE_REG_SRC(0x9) | MOVE_AUX(0x0))
 #define MOVE_SRC_DECO_ALIGN		(MOVE_REG_SRC(0xA) | MOVE_AUX(0x0))
 #define MOVE_SRC_C1_ALIGN		(MOVE_REG_SRC(0xA) | MOVE_AUX(0x1))
 #define MOVE_SRC_C2_ALIGN		(MOVE_REG_SRC(0xA) | MOVE_AUX(0x2))
@@ -256,7 +258,7 @@
 #define MOVE_SRC_C2_KEY			MOVE_REG_SRC(0xE)
 
 /* Destination */
-#define MOVE_DST(dst)			SHIFT_U32((MOVE_DST_##dst) & 0xF, 16)
+#define MOVE_DST(dst)			SHIFT_U32((MOVE_DST_##dst), 16)
 #define MOVE_DST_C1_CTX_REG		0x0
 #define MOVE_DST_C2_CTX_REG		0x1
 #define MOVE_DST_OFIFO			0x2
@@ -267,6 +269,7 @@
 #define MOVE_DST_MATH_REG3		0x7
 #define MOVE_DST_IFIFO_C1		0x8
 #define MOVE_DST_IFIFO_C2		0x9
+#define MOVE_DST_IFIFO_C2_LC2		((0x9 << 16 | MOVE_AUX(0x1)) >> 16)
 #define MOVE_DST_IFIFO			0xA
 #define MOVE_DST_PKHA_A			0xC
 #define MOVE_DST_C1_KEY			0xD
@@ -425,6 +428,9 @@
  */
 #define CMD_JUMP_TYPE		CMD_TYPE(0x14)
 
+/* Jump Select Type */
+#define JMP_JSL BIT32(24)
+
 /* Jump Type */
 #define JUMP_TYPE(type)		SHIFT_U32((JMP_##type) & 0xF, 20)
 #define JMP_LOCAL		0x0
@@ -443,14 +449,20 @@
 #define JMP_TST_ANY_COND_TRUE	0x2
 #define JMP_TST_ANY_COND_FALSE	0x3
 
+/* Jump Source to increment/decrement */
+#define JMP_SRC(src)   SHIFT_U32((JMP_SRC_##src) & 0xF, 12)
+#define JMP_SRC_MATH_0 0x0
+
 /* Test Condition */
 #define JMP_COND(cond)		SHIFT_U32((JMP_COND_##cond) & 0xFF, 8)
+#define JMP_COND_MATH(cond)	SHIFT_U32((JMP_COND_MATH_##cond) & 0xF, 8)
 #define JMP_COND_NONE		0x00
 #define JMP_COND_PKHA_IS_ZERO	0x80
 #define JMP_COND_PKHA_GCD_1	0x40
 #define JMP_COND_PKHA_IS_PRIME	0x20
 #define JMP_COND_MATH_N		0x08
 #define JMP_COND_MATH_Z		0x04
+#define JMP_COND_NIFP		0x04
 #define JMP_COND_MATH_C		0x02
 #define JMP_COND_MATH_NV	0x01
 
@@ -550,6 +562,7 @@
 #define PKHA_OUTSEL_A		0x1
 
 #define PKHA_FUNC(func)		SHIFT_U32((PKHA_FUNC_##func) & 0x3F, 0)
+#define PKHA_FUNC_CPY_NSIZE		0x10
 #define PKHA_FUNC_CPY_SSIZE		0x11
 #define PKHA_FUNC_MOD_ADD_A_B		0x02
 #define PKHA_FUNC_MOD_SUB_A_B		0x03
@@ -646,11 +659,19 @@
 /* Shared Secret */
 #define PDB_SHARED_SECRET_PD1	SHIFT_U32(1, 25)
 
+/* DSA Signatures */
+#define PDB_DSA_SIGN_N(len) SHIFT_U32((len) & (0x7F), 0)
+#define PDB_DSA_SIGN_L(len) SHIFT_U32((len) & (0x3FF), 7)
+
 /* SGT Flags Signature */
 #define PDB_SGT_PKSIGN_MSG	SHIFT_U32(1, 27)
 #define PDB_SGT_PKSIGN_SIGN_C	SHIFT_U32(1, 26)
 #define PDB_SGT_PKSIGN_SIGN_D	SHIFT_U32(1, 25)
 
+/* DSA Verify */
+#define PDB_DSA_VERIF_N(len) SHIFT_U32((len) & (0x7F), 0)
+#define PDB_DSA_VERIF_L(len) SHIFT_U32((len) & (0x3FF), 7)
+
 /* SGT Flags Verify */
 #define PDB_SGT_PKVERIF_MSG	SHIFT_U32(1, 27)
 #define PDB_SGT_PKVERIF_SIGN_C	SHIFT_U32(1, 26)
diff --git a/core/drivers/crypto/caam/include/caam_desc_helper.h b/core/drivers/crypto/caam/include/caam_desc_helper.h
index e3688983..3afd1f12 100644
--- a/core/drivers/crypto/caam/include/caam_desc_helper.h
+++ b/core/drivers/crypto/caam/include/caam_desc_helper.h
@@ -82,11 +82,27 @@ static inline void dump_desc(uint32_t *desc)
 
 /*
  * Jump Local of class 1 to descriptor offset if test meet the
- * condition ond
+ * condition cond
  */
 #define JUMP_C1_LOCAL(test, cond, offset)                                      \
 	JUMP_LOCAL(CLASS_1, test, cond, offset)
 
+/*
+ * First decrement specified source then
+ * Jump Local of no class to descriptor offset if test meet the
+ * condition cond
+ */
+#define JUMP_CNO_LOCAL_DEC(test, src, cond, offset)                            \
+	(CMD_JUMP_TYPE | CMD_CLASS(CLASS_NO) | JUMP_TYPE(LOCAL_DEC) |          \
+	 JUMP_TST_TYPE(test) | JMP_SRC(src) | (cond) |                         \
+	 JMP_LOCAL_OFFSET(offset))
+
+/*
+ * Wait until test condition meet and jump next
+ */
+#define WAIT_COND(test, cond)                                                  \
+	(JUMP_LOCAL(CLASS_NO, test, JMP_COND(cond), 1) | JMP_JSL)
+
 /*
  * Jump No Local of class cla to descriptor offset if test meet the
  * condition cond
@@ -198,6 +214,13 @@ static inline void dump_desc(uint32_t *desc)
 	(CMD_STORE_TYPE | CMD_CLASS(cla) | STORE_SRC(src) |                    \
 	 STORE_OFFSET(off) | STORE_LENGTH(len))
 
+/*
+ * Store value of length len from register src of class cla
+ */
+#define ST_NOIMM_SEQ(cla, src, len)                                            \
+	(CMD_STORE_SEQ_TYPE | CMD_CLASS(cla) | STORE_SRC(src) |                \
+	 STORE_LENGTH(len))
+
 /*
  * FIFO Store from register src of length len
  */
@@ -228,6 +251,13 @@ static inline void dump_desc(uint32_t *desc)
 	(CMD_FIFO_STORE_TYPE | CMD_SGT | FIFO_STORE_EXT |                      \
 	 FIFO_STORE_OUTPUT(src))
 
+/*
+ * SEQ FIFO Store from register src of length len
+ */
+#define FIFO_ST_SEQ(src, len)                                                  \
+	(CMD_SEQ_FIFO_STORE_TYPE | FIFO_STORE_OUTPUT(src) |                    \
+	 FIFO_STORE_LENGTH(len))
+
 /*
  * RNG State Handle instantation operation for sh ID
  */
@@ -393,6 +423,14 @@ static inline void dump_desc(uint32_t *desc)
 	(CMD_OP_TYPE | OP_TYPE(PKHA) | PKHA_ALG | PKHA_FUNC(CPY_SSIZE) |       \
 	 PKHA_CPY_SRC(src) | PKHA_CPY_DST(dst))
 
+/*
+ * PKHA Copy N-Size function from src to dst. Copy number of words specified
+ * in PKHA N size register
+ */
+#define PKHA_CPY_NSIZE(src, dst)                                               \
+	(CMD_OP_TYPE | OP_TYPE(PKHA) | PKHA_ALG | PKHA_FUNC(CPY_NSIZE) |       \
+	 PKHA_CPY_SRC(src) | PKHA_CPY_DST(dst))
+
 /*
  * PKHA Operation op result into dst
  */
diff --git a/core/drivers/crypto/caam/include/caam_trace.h b/core/drivers/crypto/caam/include/caam_trace.h
index 60ffc366..baf7c4fb 100644
--- a/core/drivers/crypto/caam/include/caam_trace.h
+++ b/core/drivers/crypto/caam/include/caam_trace.h
@@ -40,6 +40,7 @@
 #define DBG_TRACE_MP	 BIT32(12) /* MP trace */
 #define DBG_TRACE_SM	 BIT32(13) /* Secure Memory trace */
 #define DBG_TRACE_DH	 BIT32(14) /* DH trace */
+#define DBG_TRACE_DSA	 BIT32(15) /* DSA trace */
 
 /* HAL */
 #if CAAM_DBG_TRACE(HAL)
@@ -278,6 +279,29 @@
 #define DH_DUMPBUF(...)
 #endif
 
+/* DSA */
+#if CAAM_DBG_TRACE(DSA)
+#define DSA_TRACE DRV_TRACE
+#if CAAM_DBG_DESC(DSA)
+#define DSA_DUMPDESC(desc)                                                     \
+	do {                                                                   \
+		MP_TRACE("DSA Descriptor");                                    \
+		DRV_DUMPDESC(desc);                                            \
+	} while (0)
+#else
+#define DSA_DUMPDESC(desc)
+#endif
+#if CAAM_DBG_BUF(DSA)
+#define DSA_DUMPBUF DRV_DUMPBUF
+#else
+#define DSA_DUMPBUF(...)
+#endif
+#else
+#define DSA_TRACE(...)
+#define DSA_DUMPDESC(desc)
+#define DSA_DUMPBUF(...)
+#endif
+
 #if (TRACE_LEVEL >= TRACE_DEBUG)
 #define DRV_TRACE(...)                                                         \
 	trace_printf(__func__, __LINE__, TRACE_DEBUG, true, __VA_ARGS__)
-- 
2.17.1

